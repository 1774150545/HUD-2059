hdu 2062 Subset sequence
hdu 2062传送门：http://acm.hdu.edu.cn/showproblem.php?pid=2062

   Problem Analyse
 
考虑一个集合 An = { 1, 2, ..., n}。比如，A1={1}，A3={1,2,3}。我们称一个非空子集元素的排列为一个子集序列。对所有的子序列按字典顺序排序。你的任务就是给出第m个子序列。

Algorithm Analyse
  首先我们来看看An一共有多少个子集。
n=1时,只有{1}一个子集合 
n=2时，就有:
{1}, {2}, 
{1, 2}, {2, 1}
4个子集合。
n=3时，有
{1}, {2}, {3}, 
{1, 2}, {1, 3}, {2, 1}, {2, 3}, {3, 1}, {3, 2}, 
{1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}

也许你发现规律了。An子集合的个数为:
C1n·A11 + C2n·A22 + ... + Cnn·Ann
这个公式是对的。但我们换个角度看。
n=3时，有
{1}
{1, 2}
{1, 2, 3}
{1, 3}
{1, 3, 2} 
{2}
{2, 1}
{2, 1, 3}
{2, 3}
{2, 3, 1}
{3}
{3, 1}
{3, 1, 2}
{3, 2}
{3, 2, 1}

不难发现，An可以按首数字分成n组，而每组里除了第一项，剩下的就是An-1的子集合了。
∴f(n) = n[f(n-1) + 1]
f(1) = 1 
我们拿测试数据3 10来做个示范，解释一下怎么求解。
因为n=3，所以开始数组里1、2、3三个数。
我们知道，n=2时，有4种排列，所以上面n=3可以分成三组，每组5个(加上空集)。
因此第10个在第二组里。所以第一个是2，把2输出。原来的数组里删除2，变成1、3两个数。然后10 - (2 - 1) * 5 = 5，即它在第2组的第5个。
减去首个空集合，5 - 1 = 4 ≠ 0，表示2后面还有数字。
因为A1 = 1是，所以再第2组里又可以分成两组，每组2个(加上空集)。
所以，4在第2组，剩下的数组中，第二个元素是3，所以输出3。再把数组里的3删除，剩下1一个数。
然后4 - (2 - 1) * 2 = 2，既它是第2组的第2个。
减去首个空集，2 - 1 = 1 ≠ 0，表示2后面还有数字。
按上面的方法继续下去，直到n = 0 或 后面为空集为止。
最后输出数组里的第1个元素，就得到2 3 1，就是解了。
从上面的计算可以看出来，本题目的关键是先求的An中每一组的个数g(n)
不难得出:g(n) = f(n) / n
∵f(n) = n[f(n-1) + 1]
∴g(n) = n[f(n-1) + 1] / n = f(n-1) + 1
∵f(n-1) = (n-1) * g(n-1)
∴g(n) = (n-1) * g(n-1) + 1

代码如下：
壹
#include <iostream>
//Subset sequence
//求第几个子集
#include<stdio.h>


using namespace std;
/*int main( )
{
   int a[21] = {0}, i;
   long long p[21] = {0}, n, m, t;
   while (cin >> n >> m)
   {
        for (i = 0; i < 21; i++)
        a[i] = i;
        p[1] = 1;
        for (i = 2; i < 21; i++)
        p[i] = p[i-1] * (i - 1) + 1; //计算出每个数字有几种排列，如N=1时，数字1开头有1种排列；
        //N=2时，数字1开头有2种排列；N=3时, 有5种排列。
        while (n-- && m)
       {
           t = m / p[n+1] + (m % p[n+1] ? 1 : 0); //计算出该m是在哪一组
           cout << a[t];
           for (i = t; i <= n; i++)
            a[i] = a[i+1];//删去已经排列那个数字#########
           m = m - ((t - 1) * p[n + 1] + 1); // 去掉前面的小于t开头的组合，且将去掉一个仅有t的集合
           if (m==0)
            cout << "\n";
           else cout << " ";
       }
   }
    return 0;
}*/
//162


贰
#include <stdio.h>


int main()
{
    int i,n,t;//n：一共多少元素<=20。t：所求子集位于分组后的第几组
    __int64 m;//位于第几个子集
    __int64 c[21]={0};//后面将子集分组后平均每组个数，如:c[2]表示n=2时的分组每组中子集数
    int s[21];//后面将子集按字典序分组后每组的初始首元素,组数<=20
    for (i=1;i<21;i++)
        c[i]=c[i-1]*(i-1)+1;//推导出来的c[n]=(n-1)*c[n-1]+1
    while (scanf("%d%I64d",&n,&m)!=EOF)

    {
        for(i=0;i<21;i++)

            s[i]=i;//每循环一次就重新归位每组首元素       s[0]=0
                    while (n>0&&m>0)
        {
            t=m/c[n]+(m%c[n]>0?1:0);

            if(t>0)//得到第m个子集在分组后的第t组,若t>0
            {

                printf("%d",s[t]);

                for(i=t;i<=n;i++)

                   // s[i]=s[i+1];//划去只有s[i]的这一组  s[10]变成s[9] 相当于去除了空集  是否是空集由下面m==0 判断
//s[i]=s[i];
                m-=((t-1)*c[n]+1);//减去(t-1组总子集数+1）,m变为表示在剩余子集中位于第几个
//m-=((t-1)*c[n]);
                putchar(m==0?'\n':' ');

            }

            n--;//依次递减,直到执行上面的if代码或退出

        }

    }

    return 0;
}

//62


具体操作步骤如下：
程序必需因素：
    1、每组子集的个数c[n];
    2、每组子集的首元素;
    3、所求子集位于当前分组后的第几组中t
    4、所求子集位于该组的第几个
主要递归步骤：
1、求出所在组t
2、输出所在组t的首元素s[t](同一组首元素相同)
3、将该子集的下一个元素到最后一个的值+1,注意这个规律：在第i组，首元素为i，删除首元素后，在第i个子集后首元素均变大+1.

程序步骤实例解说：
n=3，m=10时，有
{1}
{1, 2}
{1, 2, 3}
{1, 3}
{1, 3, 2}
{2}
{2, 1}
{2, 1, 3}
{2, 3}
{2, 3, 1}
{3}
{3, 1}
{3, 1, 2}
{3, 2}
{3, 2, 1}


1。求得t=2
先输出第2组首元素2，再去掉前面不需要的分组，和首元素,剩下唯一一组子集：
因此此时m-=((t-1)*c[n]+1)=4
//{}
{1}
{1, 3}
{3}
{3, 1}
此时的s[t~~n]均变大+1
2。然后再分成两组， t=m/c[n]+(m%c[n]>0?1:0)求得当前在第t=2组
输出第2组首元素3，再去掉前面不需要的分组，和首元素,剩下唯一一组子集
因此此时m-=((t-1)*c[n]+1)=1
//{}
{1}
3。然后剩最后一组， t=m/c[n]+(m%c[n]>0?1:0)求得当前在第t=1组
输出第1组首元素1，和首元素,剩下唯一一组子集
{}//空集
因此此时m-=((t-1)*c[n]+1)=0
最后退出。
